# Protobuf implementation in Jai

Implementation of [Google Protocol Buffers](https://protobuf.dev/) "Protobuf"
serialization format in pure Jai.

Protobuf uses a language-neutral message description format which can be used
to interchange data between different programming languages, implemented by
generating source code for each language for De/Serialization.
The official C++ repo is [here](https://github.com/protocolbuffers/protobuf).

## Example

The protocol buffer text format:

```proto
message Person {
    string name = 1 [default = "?"];
    int32 age = 2;
    float height_cm = 3;
    repeated sint32 favourite_numbers = 4;
}
```

Produces the following Jai structure and function definitions:

```jai
Person :: struct {
    name: string = "?";
    age: s32;
    height_cm: float32;
    favourite_numbers: [..]s32;
}

Serialize : (message: Person) -> []u8;
Deserialize : (message: *Person, bytes: []u8) -> ok: bool, used: s64 = 0;
FreeContents : (message: *Person);
```

The code can be generated by calling:

```jai
jai_code : string = generate_jai(parse_proto_file("person.proto"));
// Write to file, ...
// Or inserted directly at compile time:
#insert #run generate_jai(parse_proto_file("person.proto"));
```

## Quick start

In your projects directory, add this repo as a module. Jai automatically looks
in ./modules/ for modules, so that's a good place to put it. If you use git,
you can submodule it, or otherwise copy it in there.

```sh
git init
git submodule add https://github.com/segcore/jai-protobuf.git  modules/Protobuf
```

```jai
// file: main.jai
#import "Basic";
#import "Protobuf";

#insert #run generate_jai(parse_proto_file("modules/Protobuf/examples/some_things.proto"));

main :: () {
    group: Group;
    group.group_name = "Players";
    array_add(*group.people, .{name = "Bob", age = 42, height_cm = 169.4});
    print("group: %   bytes: %\n", group, Serialize(group));
}
```

## API

The main parsing and code generation is in `generator.jai`, which has:

```
parse_proto_text :: (data: string, source_path: string = "") -> ProtoFile {...}
parse_proto_file :: (source_path: string) -> ProtoFile {...}
generate_jai :: (p: ProtoFile, protobuf_import := "") -> string {...}
```

Primitive encode and decode functions are available in respective files. This
can be used without using the code generation (which requires running the
compiler to be useful). This could be used to create a tool which encodes and
decodes any protobuf at runtime, for example.

## Why use Protocol Buffers?

1. If you need to interoperate with another application which uses this
   serialization format.
2. To serialize/deserialize data for your own projects, if it suits your
   purposes. The pure Jai implementation is less painful to use than the C++
   one.

## Details

Structures, enumerations, and serialization-related functions are generated
according to protobuf text descriptions.
See the complete example's [protobuf description](./examples/many_things.proto)
and its [generated code](./examples/generated/many_things.proto.jai).
The generated code is very simple -- normal structures with (public) fields
just as you would write them normally. No added indirection. Repeated fields
use `[..]type` and can be used directly. Use the language's context features to
setup custom allocators.

The parser is very relaxed. **It ignores anything it doesn't understand** and
just keeps soldiering on. This is good in that it doesn't need every possible
feature to be implemented here to be able to parse realistic external files. It
should work for correct protobuf files, but presently gives poor messaging for
failures/unknown features.

The parser/generator also does not follow all Protobuf rules, because it does not need
to in order to work. For example, you can use an Enum or Message from another protobuf
text file without importing it. The parser and code generation don't need it.
If the other file is eventually `#load`ed at build time, it will work. Otherwise, it will
be a compile time error. This simplifies the process too -- leveraging the compiler to
do all of the linking work. Afterall, it is going to have to do it anyway, so why
double up?

## Feature set

* [x] Encode primitive types
* [x] Decode primitive types
* [x] Parse protobuf description files
  * [x] Basic
  * [x] Nested messages/enums
  * [x] comments (ignored)
  * [x] import (ignored)
  * [x] package (passed to user)
  * [x] reserved fields (ignored)
  * [x] options
    * [x] deprecated, packed, default
  * [ ] `Any` and other well-known types
* [x] Generate Jai enums
* [x] Generate Jai structures
* [x] Generate Jai serialize functions
* [x] Generate Jai deserialize functions
* [x] Repeated fields
  * [x] Unpacked repeated fields
  * [ ] Packed repeated fields - Encode
  * [x] Packed repeated fields - Decode
* [x] Map types
* [x] One-of types

Not intended to be implemented:
* Field presence information
* Message "extensions"
